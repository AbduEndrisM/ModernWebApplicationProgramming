SPA: when we ask for a single page (for the first time) the server response the whole app (empty page of all).

Angular:
 - fully ES6 ECMA 2015 // check it on tscofig.ts
 - with a concept of web components(components reusable, encapsulated and has their own state)
 - for all types of apps
 -

//all angular offical apis start with @angular/xxx...

 npm @angular/cli -g
 ng   new kuytiuytuuyt  / ng new myapp
ng serve //serve

ng s -o //serve and open

//new component - without folder
ng generate g c abdu -t -s --flat --spec=false


main.ts
// main.ts id the first file that bootstrap our angular app - appModule (can be any name )
show (provide) a link with the DOM 

bootstrapMoodule (appmodule) - is a bubble which encapsulate a certain logic \
we define all our bubble modules inside a compoentnt. 

has 4 properties - declarations, imports, providers, bootstrap.

services[provider]: piece of code we are goonna use over and over.
Angular has abuilt in dependecy injection 

Angular6 we dont provide services anymore.



app.componnet
has 3 properties(decorator properties) slector, template and style
selector and template are mandatory, style is optional.

each componne ths 3 states - selector and view

//Important
data binding: can be done in 1/2 ways. map app state to the DOM  (using {{xxx}}) or setup from DOM to my app

the state is written inside the class and the DOM element would be inside the @component section

encapsulation: viewEncapsulartuo.none --- make the default angular encap =off
encapsulation: viewEncapsulartuo.emulation ---  the default angular rendering style applied
encapsulation: viewEncapsulartuo.shadow --- make the //for modern browsers reocmmended

[] use when passing the exact datatype - number, string...
{{}} use for general use

component lifec cycle = if we implement them
construcor 
ngOnCHnage
ngOnInit = called only once
ngOnDesrory = called only once  when done
ngAfterViewInit = view is any template defined for the component = html


we can do in constructor whatever we do in ngOnInit , but the constructor is more appropriate to use it for dependency injection.

the more complex constuctor, the more difficult to test 

BrowserModule in imports (decoration) used us to import all browser tags

template reference to any element = #xxx (xxx template reerence) for the specific DOM element and we can display the enet element using {{#xxx.value}}

@viewChild((#xxx) abc  = change the template refenrece element to cutom name
use {{abc.nativeElement.value}} to access it

if it is from other component content @ContentChild

 
